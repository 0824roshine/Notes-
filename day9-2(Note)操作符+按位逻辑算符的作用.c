#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
void 右移()
{
	int a = -1, c = 16;
	int b = a >> 1;
	int d = c >> 1;
	// +  -  *  无int or float限制   ； %-取模只能用于int ； / -int之间是int，有float为float
	//_______________________________________________________________________________________
	//右移操作  >>                           (only 整数)
		 //1  算术右移 左边补原符号位
		 //2  逻辑右移 左边补0
	printf("-1右移一位%d   ", b); //
	printf("16右移一位%d \n", d); //正数的 原-反-补-相等
//储存在内存中的是补码 反码＋1是补码。
}
//_____________________________________________________________________________________
//  ！ -     +      &       sizeof     ~                 *               （int）
// 非，负值，正值，取址，类型长度，二进制位取反，--，++，间接访问解引用。  强制类型转换
//_____________________________________________________________________________________
//+ ,-, *,/,%,>>,<<,&,|,^,    写在单个等号前面，     复合赋值符
//_______________________________________________________________
void 按位与_或_异或()
 {
	int a = 3,b = 5;
	int c = a & b; int d = a | b; int e = a ^ b;
	printf("%d  %d  %d   ", c, d, e);
 }
void 不用中间值替换ab(int* A, int* B)    //离谱
{
	*A = *A + *B;
	*B = *A - *B;
	*A = *A - *B;
}
void 用按位异或替换ab(int* C, int* D)    //更离谱
{
	*C = *C ^ *D;
	*D = *C ^ *D;
	*C = *C ^ *D;
}

int main()   //求一个整数二进制补码1的个数
{
	int num = 15; int count = 0;
	int NUM =-1; int COUNT = 0; int i = 0;
	while (num != 0)
	{
		if (1 == (num % 2))
			count++;
		num = num / 2;
	}
	for (i = 0; i < 32; i++)            // 直接操作补码，就能求负数了。
	{
		if (1 == ((NUM >> i) & 1))     // 逐位与1按位与。 按位与操作的是补码！
			COUNT++;
	}
	printf("%d\n", count);
	printf("%d", COUNT);
	return 0;
}